{"name":"pyqcy","body":"# pyqcy\r\n_pyqcy_ \\[pyksi:\\] is a test framework that supports unique testing model, inspired by the\r\nbrilliant _QuickCheck_ library for Haskell. Rather than writing fully-fledged test cases,\r\nyou only need to define logical **properties** that your code has to satisfy.\r\nBased on that, _pyqcy_ will automatically generate test cases - hundreds of them, in fact!\r\n\r\n## Example\r\n\r\n```python\r\nfrom pyqcy import qc, int_ main\r\n\r\n@qc\r\ndef addition_actually_works(\r\n    x=int_(min=0), y=int_(min=0)\r\n):\r\n    the_sum = x + y\r\n    assert the_sum >= x and the_sum >= y\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n```\r\n```\r\n$ python ./example.py\r\naddition_actually_works: passed 100 tests.\r\n```\r\nYes, that's 100 distinct test cases. _pyqcy_ has generated them all for you!\r\n\r\n## Installation\r\n\r\nEither from PyPI:\r\n\r\n```\r\n$ pip install pyqcy\r\n```\r\nor directly from GitHub if you want the bleeding edge version:\r\n\r\n```\r\n$ git clone git://github.com/Xion/pyqcy.git\r\n$ cd pyqcy\r\n$ ./setup.py develop\r\n```\r\n\r\n## Usage\r\n\r\nTesting with _pyqcy_ is mainly about writing **properties** which we expect for our code to hold.\r\nThey take the form of a Python function decorated with <code>@qc</code>:\r\n\r\n```python\r\nfrom pyqcy import *\r\n\r\n@qc\r\ndef sorting_preserves_length(\r\n    l=list_(of=int, min_length=1, max_length=128)\r\n):\r\n    before_sort = l\r\n    after_sort = list(sorted(l))\r\n    assert len(before_set) == len(after_sort)\r\n```\r\nInside such function, parameters work like quantified variables. We can use the default arguments' syntax\r\nto constrain the set of values for those variables. So here we define <code>l</code>\r\nas **arbitrary**, non-empty <code>list</code> of <code>int</code>s with maximum length of 128 items.\r\nFor every test for this property, _pyqcy_ will automatically generate appropriate list and see\r\nwhether our assertions hold ground.\r\n\r\n### Value generators\r\n\r\nSupport for all standard Python types - including lists (<code>list_</code>), tuples (<code>dict_</code>)\r\nand dictionaries (<code>dict_</code>) - is readily available.\r\nIf we want to test against instances of custom type, we have to say how to construct an arbitrary\r\n(i.e. random) instance of this type:\r\n\r\n```python\r\nfrom pyqcy import *\r\n\r\n@arbitrary(OurOwnClass)\r\ndef our_own():\r\n    obj = OurOwnClass()\r\n    obj.some_string = next(str_(max_length=32))\r\n    obj.some_float = next(float_())\r\n    return obj\r\n```\r\nOnce this is done, we can use the new generator to define properties regarding our class:\r\n\r\n```python\r\n@qc\r\ndef forbs_correctly(obj=OurOwnClass): # obj=our_own works too\r\n    assert obj.forb() == len(obj.some_string) + 42\r\n```\r\n\r\n### Statistics\r\n\r\nThe test cases for our properties are generated at random. Because of that, it could be useful\r\nto have a little more insight on what part of problem's domain they actually cover. _pyqcy_\r\nhas some statistical tools that help to obtain this information.\r\n\r\nFirst one is the <code>collect</code> function. As the name implies, it **collects** test\r\ncases that share particular value (given as argument). At the end, a \"histogram\" of those\r\nvalues is displayed, showing how often they occurred:\r\n\r\n```python\r\nfrom pyqcy import *\r\n\r\n@qc\r\ndef sorting_short_lists(\r\n    l=list_(int, min_length=1, max_length=5)\r\n):\r\n    yield collect(len(l))\r\n    assert list(sorted(l))[0] = min(l)\r\n```\r\n\r\n```\r\nsorting_short_lists: passed 100 tests.\r\n20.00%: 1\r\n20.00%: 2\r\n20.00%: 3\r\n20.00%: 4\r\n20.00%: 5\r\n```\r\n\r\nFor more complicated (or coarse) clustering, there is also the <code>classify</code> function.\r\nPassed a boolean condition and a label, it will \"stamp\" a particular test case with given label\r\nif the condition is true:\r\n\r\n```python\r\nfrom pyqcy import *\r\nimport random\r\n\r\n@qc\r\ndef sorting_works(l=list_(int, max_length=99)):\r\n    yield classify(len(l) == 0, \"empty list\")\r\n    yield classify(len(l) < 10, \"short list\")\r\n    yield classify(len(l) >= 50, \"long list\")\r\n    s = list(sorted(l))\r\n    i = random.randint(0, len(l) - 1)\r\n    j = random.randint(0, len(l) - 1)\r\n    assert (i <= j) == (s[i] <= s[j])\r\n```\r\n\r\n```\r\nsorting_works: passed 100 tests.\r\n 1.00%: empty list, short list\r\n10.00%: short list\r\n50.00%: long list\r\n40.00%: <rest>\r\n```\r\n\r\nNote that in current version of _pyqcy_, it is **essential** to <code>yield</code> any statistical\r\ninformation (such as <code>collect</code> and <code>classify</code> calls) so it can be picked up\r\nby the test harness.\r\n\r\n## Going further\r\n\r\nAlthough already usable, _pyqcy_ is still in development phase.\r\nThe aim is to have it mimic the Haskell's _QuickCheck_ very closely while remaining\r\npythonic and taking advantage of dynamic nature of the language.\r\n\r\nThoughts, opinions, ideas and contributions are all very welcome! Head over to\r\n[GitHub](http://github.com/Xion/pyqcy) for more info.","tagline":"QuickCheck-like testing framework for Python","google":"UA-30641076-1","note":"Don't delete this file! It's used internally to help with page regeneration."}