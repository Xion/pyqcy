Using generators
================

.. currentmodule:: pyqcy.arbitraries

To provide test data for your properties, *pyqcy* has a set of generators
for all common types and use cases, including Python's
:ref:`scalar types <scalar-arbitraries>`
and :ref:`collections <collection-arbitraries>`. It is also easy
to :ref:`combine <arbitrary-combinators>` several generators into
one - up to creating :ref:`complex data structures <data-arbitrary>`
on the fly.

Still, if those are not enough, you can always define your own generator.
This is especially handy for custom classes, as it enables you to write
properties that should be true for their instances.
To create a custom generator, simply define a function that returns
an appropriate random object and decorate it with the :func:`arbitrary`
decorator::

    from pyqcy import *

    @arbitrary(MyClass)
    def my_class():
        obj = MyClass()
        obj.some_field = next(int_(min=0, max=1024))
        obj.other_field = next(str_(max_length=64))
        return obj

Now you can write properties which use the new generator::

    @qc
    def forbs_correctly(obj=MyClass):
        assert obj.forb() >= obj.some_field * len(obj.other_field)

Because we have passed a type argument to :func:`arbitrary`,
we can use our class name (`MyClass`) in place of generator name
(`my_class`) - although the latter is of course still possible.

.. autofunction:: arbitrary(type_=None)


Built-in types
**************

.. currentmodule:: pyqcy.arbitraries.standard

Most Python types are conveniently supported by *pyqcy*
and generators for them are readily available. They should
cover a vast majority of typical use cases.


.. _scalar-arbitraries:

Scalar types
------------

Numeric and string types have parametrized generators that allow
for setting desired range of produces values. But if we are fine
with the defaults, we can simply use the types directly, as seen
in this example:

.. code-block:: python

    @qc
    def vec2d_length_is_positive(x=float, y=float):
        return vec2d_len(x, y) >= 0.0

.. autofunction:: int_(min, max)

.. autofunction:: float_(min, max)

.. autofunction:: complex_(min_real, max_real, min_imag, max_imag)

.. autofunction:: str_(of, min_length, max_length)



Tuples
------

Tuples can be produced by combining several generators together
through :func:`tuple_` function. There are also handy shortcuts
for pairs, triplers and quadruples that consists of values
from the same source.

.. autofunction:: tuple_(*generators, of, n)

.. autofunction:: two(of)

.. autofunction:: three(of)

.. autofunction:: four(of)


.. _collection-arbitraries:

Collections
-----------

Lists and dictionaries can be generated by giving their minimum
and maximum size, as well as a generator for their elements.
For dictionaries, you can either specify a separate generators
for keys and values, or a single generator that outputs
2-element tuples.

.. autofunction:: list_(of, min_length, max_length)

.. autofunction:: dict_(keys, values, items, min_length, max_length)


.. _arbitrary-combinators:

Combinators
***********

.. currentmodule:: pyqcy.arbitraries.combinators

.. autofunction:: one_of(*generators)

.. autofunction:: frequency(*distribution)

.. autofunction:: elements(*list)


.. _data-arbitrary:

Data structures
---------------

.. autofunction:: data


Applying functions
------------------

.. autofunction:: apply
