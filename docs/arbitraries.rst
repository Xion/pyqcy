Using generators
================

.. currentmodule:: pyqcy.arbitraries

To provide test data for your properties, *pyqcy* has a set of generators
for all common types and use cases, including Python's
:ref:`scalar types <scalar-arbitraries>`
and :ref:`collections <collection-arbitraries>`. It is also easy
to :ref:`combine <arbitrary-combinators>` several generators into
one - up to creating :ref:`complex data structures <data-arbitrary>`
on the fly.

Still, if those are not enough, you can always define your own generator.
This is especially handy for custom classes, as it enables you to write
properties that should be true for their instances.
To create a custom generator, simply define a function that returns
an appropriate random object and decorate it with the :func:`arbitrary`
decorator::

    from pyqcy import *

    @arbitrary(MyClass)
    def my_class():
        obj = MyClass()
        obj.some_field = next(int_(min=0, max=1024))
        obj.other_field = next(str_(max_length=64))
        return obj

Now you can write properties which use the new generator::

    @qc
    def forbs_correctly(obj=MyClass):
        assert obj.forb() >= obj.some_field * len(obj.other_field)

Because we have passed a type argument to :func:`arbitrary`,
we can use our class name (`MyClass`) in place of generator name
(`my_class`) - although the latter is of course still possible.

.. autofunction:: arbitrary(type_=None)


Built-in types
**************

Most Python types are conveniently supported by *pyqcy*
and generators for them are readily available. They should
cover a vast majority of typical use cases.


.. _scalar-arbitraries:

Numeric types
-------------

.. currentmodule:: pyqcy.arbitraries.numbers

Numeric types have parametrized generators that allow for setting
desired range of produces values. But if we are fine
with the defaults, we can simply use the types directly, as seen
in this example:

.. code-block:: python

    @qc
    def vec2d_length_is_positive(x=float, y=float):
        return vec2d_len(x, y) >= 0.0

.. autofunction:: int_(min, max)

.. autofunction:: float_(min, max)

.. autofunction:: complex_(min_real, max_real, min_imag, max_imag)


Strings
-------

.. currentmodule:: pyqcy.arbitraries.strings

For creating arbitrary texts, *pyqcy* has two generators for
ANSI and Unicode strings. You can specify what characters the
generators should draw from, as well the minimum and maximum length
of strings to generate.

.. autofunction:: str_(of, min_length, max_length)

.. autofunction:: unicode_(of, min_length, max_length)

Quite often you would also want to deal only with strings of certain
form that matches the expected input of the code you are testing.
In those cases it's useful to specify a regular expression that
autogenerated strings should match.

.. autofunction:: regex(pattern)

.. note::
   Currently the :class:`regex` reverser supports only a limited subset
   of syntactic features offered by Python regular expressions.
   For example, it doesn't support negative matches on character sets
   (`[^...]`) or backreferences to capture groups (`\\1`, `\\2`, etc.).


Tuples
------

.. currentmodule:: pyqcy.arbitraries.collections

Tuples can be produced by combining several generators together
through :func:`tuple_` function. There are also handy shortcuts
for pairs, triplers and quadruples that consists of values
from the same source.

.. autofunction:: tuple_(*generators, of, n)

.. autofunction:: two(of)

.. autofunction:: three(of)

.. autofunction:: four(of)


.. _collection-arbitraries:

Collections
-----------

.. currentmodule:: pyqcy.arbitraries.collections

Lists and dictionaries can be generated by giving their minimum
and maximum size, as well as a generator for their elements.
For dictionaries, you can either specify a separate generators
for keys and values, or a single generator that outputs
2-element tuples.

.. autofunction:: list_(of, min_length, max_length)

.. autofunction:: dict_(keys, values, items, min_length, max_length)


.. _arbitrary-combinators:

Combinators
***********

.. currentmodule:: pyqcy.arbitraries.combinators

If you want to have a generator that produces values of more than one type,
use the simple :func:`one_of` function or the more sophisticated
:func:`frequency` combinator.

For a simpler task of always choosing a value from a predefined
set of objects, the :func:`elements` function will come handy.

.. autofunction:: one_of(*generators)

.. autofunction:: frequency(*distribution)

.. autofunction:: elements(*list)


.. _data-arbitrary:

Data structures
---------------

For testing higher level code, it is often required to prepare more complex
input data and not just simple, uniform collections of elements. Even then,
it can be possible to avoid writing a custom generator if we use the
:func:`data` function.

.. autofunction:: data


Applying functions
------------------

Yet another way of combining generators is to use them as building blocks
for whole object *pipelines*. This is possible thanks to :func:`apply`
combinator.

.. autofunction:: apply
